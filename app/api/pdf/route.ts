import { NextResponse } from "next/server";
import PDFDocument from "pdfkit/js/pdfkit.standalone";
import { Readable } from "stream";
import { requireGoogleAuth } from "@/lib/requireGoogleAuth";

/* ================= HELPERS ================= */

function bufferFromStream(stream: Readable): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];
    stream.on("data", (chunk) => chunks.push(chunk));
    stream.on("end", () => resolve(Buffer.concat(chunks)));
    stream.on("error", reject);
  });
}

/* ================= WATERMARK ================= */
const PAGE_WIDTH = 595.28;
const PAGE_HEIGHT = 841.89;

function applyWatermarkToAllPages(doc: any, text: string) {
  const range = doc.bufferedPageRange();
  const pages = (doc as any)._pageBuffer; // internal but stable

  for (let i = 0; i < range.count; i++) {
    const page = pages[i];

    // ðŸ›‘ SKIP EMPTY PAGES
    if (!page || !page.content || page.content.length === 0) {
      continue;
    }

    doc.switchToPage(i);
    doc.save();;

    /* ================= TOP DIAGONAL ================= */
    doc.rotate(-30, {
      origin: [PAGE_WIDTH / 2, PAGE_HEIGHT * 0.25],
    });

    doc
      .fontSize(54)
      .lineWidth(1)
      .opacity(0.70)
      .fillColor("#999999")
      .strokeColor("#999999")
      .text(text, 0, PAGE_HEIGHT * 0.25, {
        width: PAGE_WIDTH,
        align: "center",
        stroke: true,
        fill: true,
      });

    doc.restore();
    doc.save();

    /* ================= BOTTOM DIAGONAL ================= */
    doc.rotate(-30, {
      origin: [PAGE_WIDTH / 2, PAGE_HEIGHT * 0.75],
    });

    doc
      .fontSize(54)
      .lineWidth(1)
      .opacity(0.70)
      .fillColor("#999999")
      .strokeColor("#999999")
      .text(text, 0, PAGE_HEIGHT * 0.75, {
        width: PAGE_WIDTH,
        align: "center",
        stroke: true,
        fill: true,
      });

    doc.restore();
    doc.save();

    /* ================= FOOTER ================= */
    doc
      .opacity(0.40)
      .fillColor("#666666")
      .fontSize(10)
      .text("Upgrade to remove watermark", 0, PAGE_HEIGHT - 40, {
        width: PAGE_WIDTH,
        align: "center",
      });

    doc.restore();
  }
}




/* ================= POST ================= */

export async function POST(req: Request) { 

 /* ================= AUTH ================= */
  const { error } = await requireGoogleAuth(req);
  if (error) return error;

  try {
    const { text, title, subject, plan } = await req.json();
    const isFreeUser = plan === "free";

    if (!text || !text.trim()) {
      return NextResponse.json(
        { error: "No content provided" },
        { status: 400 }
      );
    }

    const doc = new PDFDocument({
      size: "A4",
      margins: { top: 60, bottom: 60, left: 60, right: 60 },
      bufferPages: true, // âœ… REQUIRED
    });

    /* ---------- TITLE PAGE ---------- */

    doc.fontSize(22).text(title || "Academic Assignment", { align: "center" });
    doc.moveDown(1.5);

    doc.fontSize(14).text(
      subject ? `Subject: ${subject}` : "Generated by AI Videxa",
      { align: "center" }
    );

    doc.moveDown(2);
    doc.fontSize(12).text(
      `Date: ${new Date().toLocaleDateString()}`,
      { align: "center" }
    );

    doc.addPage();

    /* ---------- CONTENT ---------- */

    doc.fontSize(12);
    text.split("\n").forEach((line: string) => {
      if (line.trim()) {
        doc.text(line, { lineGap: 4 });
      } else {
        doc.moveDown();
      }
    });

    /* ---------- WATERMARK (AFTER ALL CONTENT) ---------- */
    if (isFreeUser) {
      applyWatermarkToAllPages(doc, "AI Videxa â€¢ Free Plan");
    }

    doc.end();

    const stream = doc as unknown as Readable;
    const buffer = await bufferFromStream(stream);

    return new NextResponse(new Uint8Array(buffer), {
      headers: {
        "Content-Type": "application/pdf",
        "Content-Disposition": `attachment; filename="acadify.pdf"`,
      },
    });
  } catch (err) {
    console.error("PDF ERROR:", err);
    return NextResponse.json(
      { error: "PDF generation failed" },
      { status: 500 }
    );
  }
}
